<?php

/**
 * @file
 * stanford_profile_helper_helper.module
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Block\BlockPluginInterface;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Config\Entity\ConfigEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Extension\Extension;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Serialization\Yaml;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Site\Settings;
use Drupal\Core\Url;
use Drupal\config_pages\ConfigPagesInterface;
use Drupal\field\FieldStorageConfigInterface;
use Drupal\menu_link_content\Entity\MenuLinkContent;
use Drupal\menu_link_content\MenuLinkContentInterface;
use Drupal\node\NodeForm;
use Drupal\node\NodeInterface;
use Drupal\search_api\IndexInterface;
use Drupal\stanford_profile_helper\StanfordProfileHelper;
use Drupal\taxonomy\TermInterface;
use Drupal\taxonomy_menu\Plugin\Menu\TaxonomyMenuMenuLink;
use Drupal\user\RoleInterface;
use Drupal\views\ViewExecutable;
use Drupal\Core\Render\Element;

/**
 * Implements hook_entity_type_alter().
 */
function stanford_profile_helper_entity_type_alter(array &$entity_types) {
  if (isset($entity_types['menu_link_content'])) {
    $entity_types['menu_link_content']->addConstraint('menu_link_item_url_constraint');
  }
}

/**
 * Implements hook_local_tasks_alter().
 */
function stanford_profile_helper_local_tasks_alter(&$local_tasks) {
  // Remove this when a new release for the scheduler module comes out above
  // 2.0.0-alpha1.
  // @see https://www.drupal.org/project/scheduler/issues/3224340.
  unset($local_tasks['scheduler.scheduled_content'], $local_tasks['scheduler.scheduled_media'], $local_tasks['scheduler.media_overview']);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function stanford_profile_helper_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state) {
  if ($form_state->get('taxonomy')['vocabulary']->id() == 'stanford_publication_topics') {
    $url = Url::fromUri('https://userguide.sites.stanford.edu/tour/publications#publications-list-page');
    $link = Link::fromTextAndUrl(t('default Publications List Page'), $url)
      ->toString();
    $form['citation_format']['#title'] = t('Citation Style');
    $form['citation_format']['#description'] = t('Select citation format for the %link. *<strong>CAUTION</strong>: The default Publication list page uses Chicago as the citation style. If you select a different citation format here, you should also update the citation format on the default Publications List Page that uses a "filter by topics" menu.', ['%link' => $link]);
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function stanford_profile_helper_redirect_presave(EntityInterface $redirect) {
  // Purge everything for the source url so that it can redirect without any
  // intervention.
  if (\Drupal::moduleHandler()->moduleExists('purge_processor_lateruntime')) {
    $source = $redirect->get('redirect_source')->getString();
    _stanford_profile_helper_purge_path($source);
  }
}

/**
 * Purges a relative path using the generated absolute url.
 *
 * @param string $path
 *   Drupal site relative path.
 *
 * @throws \Drupal\purge\Plugin\Purge\Invalidation\Exception\InvalidExpressionException
 * @throws \Drupal\purge\Plugin\Purge\Invalidation\Exception\MissingExpressionException
 * @throws \Drupal\purge\Plugin\Purge\Invalidation\Exception\TypeUnsupportedException
 */
function _stanford_profile_helper_purge_path($path) {
  $url = Url::fromUserInput('/' . trim($path, '/'), ['absolute' => TRUE])
    ->toString();

  $purgeInvalidationFactory = \Drupal::service('purge.invalidation.factory');
  $purgeProcessors = \Drupal::service('purge.processors');
  $purgePurgers = \Drupal::service('purge.purgers');

  $processor = $purgeProcessors->get('lateruntime');
  $invalidations = [$purgeInvalidationFactory->get('url', $url)];

  try {
    $purgePurgers->invalidate($processor, $invalidations);
  }
  catch (\Exception $e) {
    \Drupal::logger('stanford_profile_helper')->error($e->getMessage());
  }
}

/**
 * Implements hook_search_api_index_items_alter().
 */
function stanford_profile_helper_search_api_index_items_alter(IndexInterface $index, array &$items) {
  $exclude_pages = \Drupal::config('system.site')->get('page');
  // Remove the 404, 403, and home page from indexing for search results.
  /** @var \Drupal\search_api\Item\Item $item */
  foreach ($items as $item_id => $item) {
    $entity = $item->getOriginalObject()->getValue();
    if ($entity instanceof NodeInterface) {
      if (in_array('/node/' . $entity->id(), $exclude_pages)) {
        unset($items[$item_id]);
      }
    }
  }
}

/**
 * Implements hook_page_attachments().
 */
function stanford_profile_helper_page_attachments(array &$attachments) {
  $env = getenv('AH_SITE_ENVIRONMENT');
  // Add SiteImprove analytics for anonymous users on prod sites.
  // ACE prod is 'prod'; ACSF can be '01live', '02live', ...
  if (
    \Drupal::currentUser()->isAnonymous() &&
    ($env === 'prod' || preg_match('/^\d*live$/', $env))
  ) {
    $attachments['#attached']['library'][] = 'stanford_profile_helper/siteimprove.analytics';
  }
}

/**
 * Implements hook_filter_info_alter().
 */
function stanford_profile_helper_filter_info_alter(&$info) {
  if (
    isset($info['filter_mathjax']) &&
    \Drupal::moduleHandler()->moduleExists('mathjax')
  ) {
    $info['filter_mathjax']['class'] = 'Drupal\stanford_profile_helper\Plugin\Filter\Mathjax';
  }
}

/**
 * Implements hook_theme().
 */
function stanford_profile_helper_theme($existing, $type, $theme, $path) {
  $themes['block__stanford_basic_search'] = [
    'template' => 'block--stanford-basic-search',
    'original hook' => 'block',
  ];
  $themes['rabbit_hole_message'] = [
    'variables' => ['destination' => NULL],
  ];
  return $themes;
}

/**
 * Implements hook_library_info_alter().
 */
function stanford_profile_helper_library_info_alter(&$libraries, $extension) {
  if ($extension == 'mathjax') {
    $libraries['source']['dependencies'][] = 'stanford_profile_helper/mathjax';
    unset($libraries['setup'], $libraries['config']);
  }

  // Rely on the fontawesome module to provide the library.
  if (
    $extension == 'stanford_basic' &&
    \Drupal::moduleHandler()->moduleExists('fontawesome')
  ) {
    unset($libraries['fontawesome']);
  }
}

/**
 * Implements hook_form_alter().
 */
function stanford_profile_helper_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_state->getFormObject() instanceof NodeForm) {
    unset($form['actions']['unlock'], $form['scheduler_settings']);
    if (!empty($form['publish_on'])) {
      $form['publish_on']['#group'] = 'revision_information';
      $form['publish_on']['#weight'] = -100;
      $status_element = &$form['status']['widget']['value'];
      $status_element['#states'] = [
        'disabled' => [':input[name="publish_on[0][value][time]"]' => ['filled' => TRUE]],
      ];

      $scheduler_increment = \Drupal::state()
        ->get('stanford_profile_helper.scheduler_increment', 60 * 60 * 4);
      $hours = (int) floor($scheduler_increment / 3600);
      $mins = (int) floor($scheduler_increment / 60 % 60);
      $scheduler_increment = $hours ? "$hours hour(s)" : "$mins minute(s)";

      $help_text = [
        t('Select a date and time* to publish this content in the future.'),
        t('After scheduling the publish, it will automatically publish to your site on the scheduled date within four hours of the selected time.'),
        t('For example, if you select 8:00am as the publish time, the content will be published between 8am-12pm.'),
        t('<p><strong>*Note</strong>: You must select a time that is increments of @times, starting with 12AM.</p>', ['@times' => $scheduler_increment]),
      ];

      $form['publish_on']['widget'][0]['value']['#description'] = implode(' ', $help_text);
    }
  }
  if (strpos($form_id, 'views_form_') === 0) {
    // Remove the select all since it selects every node, not just the ones
    // from the active filters.
    // @link https://www.drupal.org/project/views_bulk_operations/issues/3055770#comment-13116724
    unset($form['header']['views_bulk_operations_bulk_form']['select_all']);

    // Sort the action menu options alphabetically.
    if (!empty($form['header']['views_bulk_operations_bulk_form']['action']['#options'])) {
      $actions_array = $form['header']['views_bulk_operations_bulk_form']['action']['#options'];
      uasort($actions_array, function ($a, $b) {
        return strcasecmp((string) $a, (string) $b);
      });
      $form['header']['views_bulk_operations_bulk_form']['action']['#options'] = $actions_array;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function stanford_profile_helper_form_views_bulk_operations_configure_action_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (!empty($form['node']['stanford_event']['su_event_date_time']['widget'])) {
    $form['node']['stanford_event']['su_event_date_time']['widget'][0]['time_wrapper']['value']['#required'] = FALSE;
    $form['node']['stanford_event']['su_event_date_time']['widget'][0]['time_wrapper']['end_value']['#required'] = FALSE;
  }
}

/**
 * Implements hook_preprocess_ds_entity_view().
 */
function stanford_profile_helper_preprocess_ds_entity_view(&$variables) {
  $variables['content']['#pre_render'][] = [
    'Drupal\stanford_profile_helper\StanfordProfileHelper',
    'preRenderDsEntity',
  ];
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function stanford_profile_helper_form_taxonomy_term_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\taxonomy\VocabularyInterface $vocabulary */
  $vocabulary = $form_state->get(['taxonomy', 'vocabulary']);
  $flat_taxonomy = $vocabulary->getThirdPartySetting('flat_taxonomy', 'flat');

  // Tweak the taxonomy term add/edit form.
  if (!empty($form['relations']['parent']) && !$flat_taxonomy) {
    $form['relations']['#open'] = TRUE;
    $form['relations']['parent']['#multiple'] = FALSE;
    $form['relations']['parent']['#title'] = t('Parent term');
    $form['relations']['parent']['#description'] = t('Select the appropriate parent item for this term.');
    $form['relations']['parent']['#element_validate'][] = '_stanford_profile_helper_term_form_validate';
  }
}

/**
 * Tweak the taxonomy term parent form value after submitting.
 *
 * Because we are changing the form to not allow multiple parents, the form
 * value needs to be changed into an array so the TermForm can still manage
 * it correctly.
 *
 * @param array $element
 *   Form element.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   Current form state object.
 * @param array $form
 *   Complete form.
 *
 * @see stanford_profile_helper_form_taxonomy_term_form_alter()
 */
function _stanford_profile_helper_term_form_validate(array $element, FormStateInterface $form_state, array $form) {
  $form_state->setValueForElement($element, [$element['#value']]);
}

/**
 * Implements hook_menu_links_discovered_alter().
 */
function stanford_profile_helper_menu_links_discovered_alter(&$links) {
  if (isset($links['admin_toolbar_tools.extra_links:media_page'])) {
    // Alter the "Media" link for /admin/content/media path.
    $links['admin_toolbar_tools.extra_links:media_page']['title'] = t('All Media');
  }
  if (isset($links['system.admin_content'])) {
    // Change the node list page for the /admin/content path.
    $links['system.admin_content']['title'] = t('All Content');
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function stanford_profile_helper_preprocess_block__help(&$variables) {
  if (\Drupal::routeMatch()->getRouteName() == 'help.main') {
    // Removes the help text from core help module. Its not helpful, and we're
    // going to provide our own help text.
    // @see help_help()
    unset($variables['content']);
  }
}

/**
 * Implements hook_help_section_info_alter().
 */
function stanford_profile_helper_help_section_info_alter(array &$info) {
  // Change "Module overviews" header.
  $info['hook_help']['title'] = t('For Developers');
}

/**
 * Implements hook_preprocess_HOOK().
 */
function stanford_profile_helper_preprocess_input__submit__paragraph_action(&$variables) {
  // Change the top banner field button from "Add @type" to "Add Top @type".
  if ($variables['element']['#name'] == 'su_page_banner_stanford_banner_add_more') {
    $variables['attributes']['value'] = t('Add Top @type', $variables['attributes']['value']->getArguments());
  }
}

/**
 * Implements hook_entity_field_access().
 */
function stanford_profile_helper_entity_field_access($operation, FieldDefinitionInterface $field_definition, AccountInterface $account, FieldItemListInterface $items = NULL) {
  if (
    $field_definition->getName() == 'status' &&
    $field_definition->getTargetEntityTypeId() == 'node' &&
    $items &&
    $items->getEntity()->id()
  ) {
    // Prevent unpublishing the home, 404 and 403 pages.
    return stanford_profile_helper_node_access($items->getEntity(), 'delete', $account);
  }

  if ($field_definition->getType() == 'entity_reference' && $field_definition->getSetting('handler') == 'layout_library') {
    $entity_type = $field_definition->getTargetEntityTypeId();
    $bundle = $field_definition->getTargetBundle();
    if (!$account->hasPermission("choose layout for $entity_type $bundle")) {
      return AccessResult::forbidden();
    }
  }
  return AccessResult::neutral();
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function stanford_profile_helper_field_widget_options_select_form_alter(&$element, FormStateInterface $form_state, $context) {
  if ($context['items']->getFieldDefinition()
      ->getName() == 'layout_selection') {
    $element['#description'] = t('Choose a layout to display the page as a whole. Choose "- None -" to keep the default layout setting.');
  }
}

/**
 * Implements hook_preprocess_toolbar().
 */
function stanford_profile_helper_preprocess_toolbar(&$variables) {
  array_walk($variables['tabs'], function (&$tab, $key) {
    if (isset($tab['attributes'])) {
      $tab['attributes']->addClass(Html::cleanCssIdentifier("$key-tab"));
    }
  });
}

/**
 * Implements hook_contextual_links_alter().
 */
function stanford_profile_helper_contextual_links_alter(array &$links, $group, array $route_parameters) {
  if ($group == 'paragraph') {
    // Paragraphs edit module clone link does not function correctly. Remove it
    // from available links. Also remove delete to avoid unwanted delete.
    unset($links['paragraphs_edit.delete_form']);
    unset($links['paragraphs_edit.clone_form']);
  }
}

/**
 * Implements hook_node_access().
 */
function stanford_profile_helper_node_access(NodeInterface $node, $op, AccountInterface $account) {
  if ($op == 'delete') {
    $site_config = \Drupal::config('system.site');
    $node_urls = [$node->toUrl()->toString(), "/node/{$node->id()}"];

    // If the node is configured to be the home page, 404, or 403, prevent the
    // user from deleting. Unfortunately this only works for roles without the
    // "Bypass content access control" permission.
    if (array_intersect($node_urls, $site_config->get('page'))) {
      return AccessResult::forbidden();
    }
  }
  return AccessResult::neutral();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function stanford_profile_helper_form_menu_edit_form_alter(array &$form, FormStateInterface $form_state) {
  $read_only = Settings::get('config_readonly', FALSE);
  if (!$read_only) {
    return;
  }

  // If the form is locked, hide the config you cannot change from users without
  // the know how.
  $access = \Drupal::currentUser()
    ->hasPermission('Administer menus and menu items');
  $form['label']['#access'] = $access;
  $form['description']['#access'] = $access;
  $form['id']['#access'] = $access;

  // Remove the warning message if the user does not have access.
  if (!$access) {
    \Drupal::messenger()->deleteByType("warning");
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function stanford_profile_helper_form_config_pages_stanford_basic_site_settings_form_alter(array &$form, FormStateInterface $form_state) {
  $form['#validate'][] = 'stanford_profile_helper_config_pages_stanford_basic_site_settings_form_validate';
}

/**
 * Validates form values.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state interface object.
 */
function stanford_profile_helper_config_pages_stanford_basic_site_settings_form_validate(array $form, FormStateInterface $form_state) {
  $element = $form_state->getValue('su_site_url');
  $uri = $element['0']['uri'];
  if (!empty($uri)) {
    // Test if the site url submmitted is equal to current domain.
    $host = \Drupal::request()->getSchemeAndHttpHost();
    if ($host != $uri) {
      $form_state->setErrorByName('su_site_url', t('This URL does not match your domain.'));
    }
  }
}

/**
 * Alter the data of a sitemap link before the link is saved.
 *
 * @param array $link
 *   An array with the data of the sitemap link.
 * @param array $context
 *   An optional context array containing data related to the link.
 */
function stanford_profile_helper_xmlsitemap_link_alter(array &$link, array $context) {

  // Get node/[:id] from loc.
  $node_id = $link['loc'];

  // Get 403 page path.
  $stanford_profile_helper_403_page = \Drupal::config('system.site')
    ->get('page.403');

  // Get 404 page path.
  $stanford_profile_helper_404_page = \Drupal::config('system.site')
    ->get('page.404');

  // If node id matches 403 or 404 pages, remove it from sitemap.
  switch ($node_id) {
    case $stanford_profile_helper_403_page:
    case $stanford_profile_helper_404_page:
      // Status is set to zero to exclude the item in the sitemap.
      $link['status'] = 0;

  }
}

/**
 * Implements hook_config_readonly_whitelist_patterns().
 */
function stanford_profile_helper_config_readonly_whitelist_patterns() {
  $default_theme = \Drupal::config('system.theme')->get('default');
  // Allow the theme settings to be changed in the UI.
  $patterns = ["$default_theme.settings"];

  // Allow the form to be submitted in the UI for specific routes that don't
  // alter the configuration, such as resetting the order of taxonomy terms.
  $routes_to_config = [
    'entity.taxonomy_vocabulary.reset_form' => 'taxonomy.vocabulary.*',
  ];
  foreach ($routes_to_config as $route => $config_pattern) {
    if (\Drupal::routeMatch()->getRouteName() == $route) {
      $patterns[] = $config_pattern;
    }
  }

  return $patterns;
}

/**
 * Implements field_group_form_process_build_alter().
 */
function stanford_profile_helper_field_group_form_process_build_alter(&$element) {
  // Hide / Show the field groups based on the enabled checkbox.
  if (isset($element['group_lockup_options'])) {
    $element['group_lockup_options']['#states'] = [
      'visible' => [
        ':input[name="su_lockup_enabled[value]"]' => [
          'checked' => FALSE,
        ],
      ],
    ];
    $element['group_logo_image']['#states'] = [
      'visible' => [
        ':input[name="su_lockup_enabled[value]"]' => [
          'checked' => FALSE,
        ],
      ],
    ];
  }
}

/**
 * Creates a states array.
 *
 * @param array $opts
 *   Allowed values.
 * @param string $input
 *   Field selector.
 *
 * @return array
 *   State array.
 */
function _stanford_profile_helper_get_lockup_states(array $opts, $input) {
  $ret = [];
  foreach ($opts as $val) {
    $ret[] = [
      $input => ['value' => $val],
    ];
  }
  return $ret;
}

/**
 * Implements hook_entity_type_update().
 */
function stanford_profile_helper_taxonomy_term_update(TermInterface $entity) {
  // https://www.drupal.org/project/taxonomy_menu/issues/2867626
  $original_parent = $entity->original->get('parent')->getString();
  if ($original_parent == $entity->get('parent')->getString()) {
    return;
  }
  $database = \Drupal::database();
  $menu_link_exists = $database->select('menu_tree', 'm')->fields('m')
    ->condition('id', 'taxonomy_menu.menu_link%', 'LIKE')
    ->condition('route_param_key', 'taxonomy_term=' . $entity->id())
    ->countQuery()
    ->execute()
    ->fetchField();

  if ($menu_link_exists > 0) {
    $database->delete('menu_tree')
      ->condition('id', 'taxonomy_menu.menu_link%', 'LIKE')
      ->condition('route_param_key', 'taxonomy_term=' . $entity->id())
      ->execute();
    \Drupal::service('router.builder')->rebuild();
  }
}

/**
 * Implements hook_preprocess_pattern_NAME().
 */
function stanford_profile_helper_preprocess_pattern_alert(&$variables) {
  $entity_type = $variables['context']->getProperty('entity_type');
  $bundle = $variables['context']->getProperty('bundle');
  $entity = $variables['context']->getProperty('entity');

  // Global Messages!
  if ($entity_type == "config_pages" && $bundle == "stanford_global_message") {

    // Validate that the entity has the field we need so we don't 500 the site.
    if (!$entity->hasField('su_global_msg_type')) {
      \Drupal::logger('stanford_profile_helper')
        ->error(t("Global Messages Config Block is missing the field su_global_msg_type"));
      return;
    }

    $color = $entity->get('su_global_msg_type')->getString();
    $variables['attributes']->addClass("su-alert--" . $color);
    $dark_bgs = ['error', 'info', 'success'];
    if (in_array($color, $dark_bgs)) {
      $variables['attributes']->addClass("su-alert--text-light");
    }
  }

}

/**
 * Implements hook_preprocess_pattern_NAME().
 */
function stanford_profile_helper_preprocess_pattern_localfooter(&$variables) {
  $entity_type = $variables['context']->getProperty('entity_type');
  $bundle = $variables['context']->getProperty('bundle');
  $entity = $variables['context']->getProperty('entity');

  // If the pattern has already been rendered and the 2nd cell is already a
  // markup object or other, we can't manipulate it.
  if (!is_array($variables['cell2'])) {
    return;
  }
  $second_content = $variables['cell2']['su_local_foot_se_co'] ?? [];
  $third_content = $variables['cell2']['su_local_foot_tr2_co'] ?? [];

  // The local footer pattern from Decanter doesn't have equal columns for each
  // of the 3 content blocks. To avoid having to completely rewrite the
  // template, we can use some special markup to wrap a couple fields with the
  // necessary classes to simulate the 4 equal columns. If the user populates
  // 1, 2, and 4 content blocks, then the 2nd block will stretch to fill take
  // the area of the missing 3rd block.
  if (\Drupal::service('renderer')->render($third_content)) {
    $variables['cell2'] = [
      '#type' => 'container',
      '#attributes' => ['class' => ['flex-container']],
      'second' => [
        '#type' => 'container',
        '#attributes' => ['class' => ['flex-md-6-of-12', 'su-margin-bottom-1']],
        'contents' => $second_content,
      ],
      'third' => [
        '#type' => 'container',
        '#attributes' => ['class' => ['flex-md-6-of-12']],
        'contents' => $variables['cell2']['su_local_foot_tr2_co'],
      ],
    ];
  }

  // Local Footer!
  if ($entity_type == "config_pages" && $bundle == "stanford_local_footer") {

    // If the lockup updates are not enabled just end.
    if (
      !$entity->hasField('su_local_foot_use_loc')
      || $entity->get('su_local_foot_use_loc')->getString() === "1"
    ) {
      return;
    }

    // Enable custom lockup.
    $variables['custom_lockup'] = TRUE;

    // Lockup customizations are enabled.
    $variables['line1'] = $entity->get('su_local_foot_line_1')->getString();
    $variables['line2'] = $entity->get('su_local_foot_line_2')->getString();
    $variables['line3'] = $entity->get('su_local_foot_line_3')->getString();
    $variables['line4'] = $entity->get('su_local_foot_line_4')->getString();
    $variables['line5'] = $entity->get('su_local_foot_line_5')->getString();
    $variables['use_logo'] = $entity->get('su_local_foot_use_logo')
      ->getString();
    $file_field = $entity->get('su_local_foot_loc_img');

    // Check if there is a file.
    if (isset($file_field->entity)) {
      $file_uri = $file_field->entity->getFileUri();
      $variables['site_logo'] = file_create_url($file_uri);
    }
    else {
      $variables['use_logo'] = "1";
    }

    // Check if there is a link and patch it through.
    $link = $entity->get('su_local_foot_loc_link')->getString();
    if ($link) {
      $variables['lockup_link'] = [
        '#markup' => URL::fromUri($link)->toString(),
      ];
    }

    // Pass through the lockup option.
    $option = $entity->get('su_local_foot_loc_op')->getString();
    $variables['lockup_option'] = 'su-lockup--option-' . $option;
  }

}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function stanford_profile_helper_form_media_library_add_form_embeddable_alter(array &$form, FormStateInterface $form_state) {

  $source_field = $form_state->get('source_field');
  $embed_code_field = $form_state->get('unstructured_field_name');
  $user = \Drupal::currentUser();
  $authorized = $user->hasPermission('create field_media_embeddable_code')
    || $user->hasPermission('edit field_media_embeddable_code');

  if (isset($form['container'][$embed_code_field])) {
    $form['container'][$embed_code_field]['#access'] = $authorized;
  }

  if (isset($form['container'][$source_field])) {
    if (!$authorized) {
      $new_desc = 'Allowed providers: @providers. For custom embeds, please <a href="@snow_form">request support.</a>';
      $args = $form['container'][$source_field]['#description']->getArguments();
      $args['@snow_form'] = 'https://stanford.service-now.com/it_services?id=sc_cat_item&sys_id=83daed294f4143009a9a97411310c70a';
      $form['container'][$source_field]['#description'] = t($new_desc, $args);
    }
    $form['container'][$source_field]['#title'] = t('oEmbed URL');
  }

}

/**
 * Implements hook_preprocess_HOOK().
 */
function stanford_profile_helper_preprocess_menu(&$variables) {
  $cache_tags = $variables['#cache']['tags'] ?? [];
  foreach ($variables['items'] as &$item) {
    // Taxonomy menu link items use the description from the term as the title
    // attribute. The description can be very long and could contain HTML. To
    // Make things easiest, just remove the title attribute.
    if ($item['original_link'] instanceof TaxonomyMenuMenuLink) {
      $attributes = $item['url']->getOption('attributes');
      unset($attributes['title']);
      $item['url']->setOption('attributes', $attributes);

      $term = \Drupal::entityTypeManager()
        ->getStorage('taxonomy_term')
        ->load($item['url']->getRouteParameters()['taxonomy_term']);
      $cache_tags[] = 'taxonomy_term_list:' . $term->bundle();
      $cache_tags = array_merge($cache_tags, $term->getCacheTags());
    }
  }
  $variables['#cache']['tags'] = array_unique($cache_tags);
}

/**
 * Implements hook_field_widget_form_alter().
 */
function stanford_profile_helper_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  if ($context['items']->getName() == 'su_page_components') {
    // Push pages to only allow 3 items per row but don't break any existing
    // pages that have 4 per row.
    $element['container']['value']['#attached']['drupalSettings']['reactParagraphs'][0]['itemsPerRow'] = 3;
  }

  if ($context['items']->getName() == 'field_media_embeddable_oembed') {
    $user = \Drupal::currentUser();
    $authorized = $user->hasPermission('create field_media_embeddable_code')
      || $user->hasPermission('edit field_media_embeddable_code');
    if (!$authorized) {
      $args = $element['value']['#description']['#items'][1]->getArguments();
      $args['@snow_form'] = 'https://stanford.service-now.com/it_services?id=sc_cat_item&sys_id=83daed294f4143009a9a97411310c70a';
      $new_desc = 'Allowed providers: @providers. For custom embeds, please <a href="@snow_form">request support.</a>';
      $element['value']['#description'] = t($new_desc, $args);
    }
  }
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function stanford_profile_helper_field_widget_datetime_timestamp_no_default_form_alter(&$element, FormStateInterface $form_state, $context) {
  // Set the date increment for scheduler settings.
  $state = \Drupal::state();
  $element['value']['#date_increment'] = $state->get('stanford_profile_helper.scheduler_increment', 60 * 60 * 4);
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function stanford_profile_helper_entity_bundle_field_info_alter(&$fields, EntityTypeInterface $entity_type, $bundle) {

  if (
    $bundle == 'stanford_global_message' &&
    !empty($fields['su_global_msg_enabled'])
  ) {
    $fields['su_global_msg_enabled']->addConstraint('global_message_constraint', []);
  }

}

/**
 * Get available roles, limited if the role_delegation module is enabled.
 *
 * @return array
 *   Keyed array of role id and role label.
 */
function _stanford_profile_helper_get_assignable_roles(): array {
  if (\Drupal::moduleHandler()->moduleExists('role_delegation')) {
    /** @var \Drupal\role_delegation\DelegatableRolesInterface $role_delegation */
    $role_delegation = \Drupal::service('delegatable_roles');
    return $role_delegation->getAssignableRoles(\Drupal::currentUser());
  }

  return user_role_names(TRUE);
}

/**
 * Implements hook_component_info_alter().
 */
function stanford_profile_helper_component_info_alter(&$components) {
  foreach ($components as $id => $component) {
    // Check if the provider of the PDB component is enabled.
    if (!_stanford_profile_helper_extension_enabled($component)) {
      unset($components[$id]);
    }
  }
}

/**
 * Traverse the PDB extension to see if it's module/theme/profile is enabled.
 *
 * @param \Drupal\Core\Extension\Extension $extension
 *   Discovered PDB extension object.
 *
 * @return bool
 *   If the PDB extension's provider is enabled.
 */
function _stanford_profile_helper_extension_enabled(Extension $extension) {
  $path = $extension->getPath();

  // Traverse down the path of the extension to find a module/theme/profile
  // that can be checked for existance.
  while ($path) {

    // An info.yml file exists in the current path, check if it's enabled as
    // a theme, profile, or module.
    if ($info_files = glob("$path/*.info.yml")) {
      $info_file_path = $info_files[0];
      $name = basename($info_file_path, '.info.yml');
      $info_file = Yaml::decode(file_get_contents($info_file_path));

      if (isset($info_file['type'])) {
        switch ($info_file['type']) {
          case 'theme':
            return \Drupal::service('theme_handler')->themeExists($name);

          case 'module':
          case 'profile':
            return \Drupal::moduleHandler()->moduleExists($name);
        }
      }
    }

    // Pop off the last part of the path to go one level higher.
    $path = explode('/', $path);
    array_pop($path);
    $path = implode('/', $path);
  }
  return FALSE;
}

/**
 * Implements hook_views_pre_view().
 */
function stanford_profile_helper_views_pre_view(ViewExecutable $view, $display_id, array &$args) {
  $display_options = &$view->getDisplay()->options;
  $default_options = &$view->getDisplay()->default_display->options;
  $filters = !empty($display_options['filters']) ? $display_options['filters'] : $default_options['filters'];

  // Change the default cache mechanism to use custom tags that we generate
  // using the node type filters that exist on the view.
  // @see \Drupal\Core\Entity\EntityBase::getListCacheTagsToInvalidate().
  if (!empty($filters['type']['entity_type']) && $filters['type']['entity_type'] == 'node') {
    $tags = [];
    foreach ($filters['type']['value'] as $node_type) {
      $tags[] = 'node_list:' . $node_type;
    }
    // If no node type tags are available, fall back to the general `node_list`.
    $tags = empty($tags) ? ['node_list'] : $tags;
    $cache = [
      'type' => 'custom_tag',
      'options' => ['custom_tag' => implode(' ', $tags)],
    ];
    $display_options['cache'] = $cache;
    $default_options['cache'] = $cache;
  }
}

/**
 * Implements hook_block_build_alter().
 */
function stanford_profile_helper_block_build_alter(array &$build, BlockPluginInterface $block) {
  if ($block->getBaseId() == 'system_menu_block') {
    $build['#cache']['tags'][] = 'stanford_profile_helper:menu_links';
    StanfordProfileHelper::removeCacheTags($build, [
      '^node:*',
      '^config:system.menu.*',
    ]);
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function stanford_profile_helper_preprocess_block__system_main_block(&$variables) {
  $variables['content']['#cache']['tags'][] = 'stanford_profile_helper:menu_links';
  // Remove node cache tags since we'll use our own cache tag above.
  StanfordProfileHelper::removeCacheTags($variables['content'], ['^config:system.menu.*']);
}

/**
 * Implements hook_preprocess_HOOK().
 */
function stanford_profile_helper_preprocess_block__system_menu_block(&$variables) {
  $variables['content']['#cache']['tags'][] = 'stanford_profile_helper:menu_links';
  // Remove node cache tags since we'll use our own cache tag above.
  StanfordProfileHelper::removeCacheTags($variables['content'], [
    '^node:*',
    '^config:system.menu.*',
  ]);
}

/**
 * Implements hook_entity_view().
 *
 * Modifies entity render arrays for fields that are of a certain type. The DS
 * module provides a limit option, but it doesn't work for all field formatters
 * because of the way the render array is structured. We'll move around the
 * field items, call the DS module function, and then correct the render array
 * back so that it still functions as expected.
 */
function stanford_profile_helper_entity_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  $list_types = [
    'entity_reference_list_label_class',
    'link_list_class',
    'list_string_list_class',
    'string_list_class',
  ];
  $components = $display->getComponents();
  $list_render_arrays = [];
  // First, move the items from the list render array into the build of the
  // field. Store the list render array for re-use later.
  foreach ($components as $field => $component) {
    if (
      isset($component['type']) &&
      in_array($component['type'], $list_types) &&
      !empty($component['third_party_settings']['ds']['ds_limit']) &&
      !empty($build[$field][0]['#items'])
    ) {
      $list_render_arrays[$field] = $build[$field][0];
      // Pull out the items to be placed higher in the build array.
      $items = $list_render_arrays[$field]['#items'];
      unset($list_render_arrays[$field]['#items']);
      foreach ($items as $delta => $item) {
        $build[$field][$delta] = $item;
      }
    }
  }
  // We must have modified some stuff, so call the DS module function.
  if ($list_render_arrays) {
    ds_entity_view_alter($build, $entity, $display, $view_mode);
  }

  foreach ($list_render_arrays as $field => $render_array) {
    $deltas = Element::children($build[$field]);
    $items = [];
    // Pull the field items back out that have been limited by DS module and
    // put those back into the render array from earlier.
    foreach ($deltas as $delta) {
      $items[$delta] = $build[$field][$delta];
      unset($build[$field][$delta]);
    }
    $render_array['#items'] = $items;
    $build[$field][0] = $render_array;
  }
}
